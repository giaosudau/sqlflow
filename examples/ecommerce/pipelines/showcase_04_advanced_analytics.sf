-- ===============================================================
-- SHOWCASE ADVANCED ANALYTICS: Demonstrates advanced SQL analytics
-- ===============================================================
-- Run with: docker compose exec sqlflow sqlflow pipeline run /app/sqlflow/demos/ecommerce_demo/pipelines/showcase_04_advanced_analytics.sf

-- Set variables for dynamic configuration
SET date = "${date|2023-10-25}";
SET output_dir = "target";

-- ===============================================================
-- PART 1: LOAD SAMPLE DATA
-- ===============================================================

SOURCE sales TYPE CSV PARAMS {
  "path": "data/sales.csv",
  "has_header": true
};

SOURCE customers TYPE CSV PARAMS {
  "path": "data/customers.csv",
  "has_header": true
};

SOURCE products TYPE CSV PARAMS {
  "path": "data/products.csv",
  "has_header": true
};

-- Load data into tables
LOAD sales_raw FROM sales;
LOAD customers_raw FROM customers;
LOAD products_raw FROM products;

-- ===============================================================
-- PART 2: DATA PREPARATION & ENRICHMENT
-- ===============================================================

-- Clean and transform the base data
CREATE TABLE sales_clean AS
SELECT
  order_id,
  customer_id,
  product_id,
  CAST(quantity AS INTEGER) AS quantity,
  CAST(CASE WHEN price <= 0 THEN NULL ELSE price END AS DOUBLE) AS price, -- Handle invalid prices
  CAST(order_date AS DATE) AS order_date,
  region,
  COALESCE(channel, 'unknown') AS channel -- Handle missing channels
FROM sales_raw;

-- Create enriched dataset with all dimensions
CREATE TABLE sales_enriched AS
SELECT
  s.order_id,
  s.customer_id,
  c.name AS customer_name,
  c.email,
  c.region,
  c.signup_date,
  COALESCE(c.account_type, 'standard') AS account_type,
  s.product_id,
  p.name AS product_name,
  p.category,
  COALESCE(p.inventory, 0) AS inventory,
  s.quantity,
  s.price,
  (s.quantity * s.price) AS total_amount,
  s.order_date,
  s.channel,
  -- Extract date components for time-based analysis
  EXTRACT(YEAR FROM s.order_date) AS year,
  EXTRACT(MONTH FROM s.order_date) AS month,
  EXTRACT(DAY FROM s.order_date) AS day
FROM sales_clean s
LEFT JOIN customers_raw c ON s.customer_id = c.customer_id
LEFT JOIN products_raw p ON s.product_id = p.product_id;

-- ===============================================================
-- PART 3: ADVANCED ANALYTICS
-- ===============================================================

-- 1. Time Series Analysis: Sales Trends Over Time
CREATE TABLE time_series_analysis AS
SELECT
  order_date,
  COUNT(DISTINCT order_id) AS orders,
  COUNT(DISTINCT customer_id) AS unique_customers,
  SUM(quantity) AS units_sold,
  SUM(total_amount) AS revenue,
  SUM(total_amount) / COUNT(DISTINCT order_id) AS avg_order_value
FROM sales_enriched
GROUP BY order_date
ORDER BY order_date;

-- 2. Cohort Analysis: Customer Retention by Signup Month
CREATE TABLE cohort_analysis AS
WITH customer_first_purchase AS (
  SELECT
    customer_id,
    MIN(order_date) AS first_purchase_date
  FROM sales_enriched
  GROUP BY customer_id
),
customer_purchases AS (
  SELECT
    se.customer_id,
    EXTRACT(YEAR FROM cfp.first_purchase_date) AS cohort_year,
    EXTRACT(MONTH FROM cfp.first_purchase_date) AS cohort_month,
    EXTRACT(YEAR FROM se.order_date) AS purchase_year,
    EXTRACT(MONTH FROM se.order_date) AS purchase_month,
    COUNT(DISTINCT se.order_id) AS num_orders,
    SUM(se.total_amount) AS total_spent
  FROM sales_enriched se
  JOIN customer_first_purchase cfp ON se.customer_id = cfp.customer_id
  GROUP BY 
    se.customer_id, 
    EXTRACT(YEAR FROM cfp.first_purchase_date),
    EXTRACT(MONTH FROM cfp.first_purchase_date),
    EXTRACT(YEAR FROM se.order_date),
    EXTRACT(MONTH FROM se.order_date)
)
SELECT
  cohort_year,
  cohort_month,
  purchase_year,
  purchase_month,
  -- Calculate months since first purchase
  (purchase_year - cohort_year) * 12 + (purchase_month - cohort_month) AS months_since_first_purchase,
  COUNT(DISTINCT customer_id) AS num_customers,
  SUM(num_orders) AS total_orders,
  SUM(total_spent) AS total_revenue,
  SUM(total_spent) / COUNT(DISTINCT customer_id) AS avg_revenue_per_customer
FROM customer_purchases
GROUP BY
  cohort_year,
  cohort_month,
  purchase_year,
  purchase_month
ORDER BY
  cohort_year,
  cohort_month,
  months_since_first_purchase;

-- 3. RFM (Recency, Frequency, Monetary) Analysis
CREATE TABLE rfm_analysis AS
WITH customer_metrics AS (
  SELECT
    customer_id,
    DATEDIFF('day', MAX(order_date), '2023-10-25') AS recency,
    COUNT(DISTINCT order_id) AS frequency,
    SUM(total_amount) AS monetary
  FROM sales_enriched
  GROUP BY customer_id
),
rfm_scores AS (
  SELECT
    customer_id,
    recency,
    frequency,
    monetary,
    NTILE(5) OVER (ORDER BY recency DESC) AS recency_score,
    NTILE(5) OVER (ORDER BY frequency) AS frequency_score,
    NTILE(5) OVER (ORDER BY monetary) AS monetary_score
  FROM customer_metrics
)
SELECT
  customer_id,
  recency,
  frequency,
  monetary,
  recency_score,
  frequency_score,
  monetary_score,
  -- Calculate RFM combined score (higher is better)
  recency_score + frequency_score + monetary_score AS rfm_score,
  -- Create RFM segments
  CASE
    WHEN recency_score >= 4 AND frequency_score >= 4 AND monetary_score >= 4 THEN 'Champions'
    WHEN recency_score >= 3 AND frequency_score >= 3 AND monetary_score >= 3 THEN 'Loyal Customers'
    WHEN recency_score >= 3 AND frequency_score >= 1 AND monetary_score >= 2 THEN 'Potential Loyalists'
    WHEN recency_score < 3 AND frequency_score >= 4 AND monetary_score >= 4 THEN 'At Risk'
    WHEN recency_score < 2 AND frequency_score >= 2 AND monetary_score >= 2 THEN 'Hibernating'
    WHEN recency_score < 2 AND frequency_score <= 2 AND monetary_score <= 2 THEN 'Lost'
    ELSE 'Regular'
  END AS customer_segment
FROM rfm_scores
ORDER BY rfm_score DESC;

-- 4. Market Basket Analysis: Product Affinities
CREATE TABLE product_affinities AS
WITH order_products AS (
  SELECT
    order_id,
    LISTAGG(product_id, ',') WITHIN GROUP (ORDER BY product_id) AS product_combination
  FROM sales_enriched
  GROUP BY order_id
),
product_pairs AS (
  SELECT
    p1.product_id AS product_1,
    p2.product_id AS product_2,
    COUNT(DISTINCT s1.order_id) AS co_occurrence
  FROM sales_enriched s1
  JOIN sales_enriched s2 ON s1.order_id = s2.order_id AND s1.product_id < s2.product_id
  JOIN products_raw p1 ON s1.product_id = p1.product_id
  JOIN products_raw p2 ON s2.product_id = p2.product_id
  GROUP BY p1.product_id, p2.product_id
)
SELECT
  product_1,
  product_2,
  co_occurrence,
  -- Calculate support and confidence metrics
  co_occurrence / (SELECT COUNT(DISTINCT order_id) FROM sales_enriched) AS support,
  co_occurrence / (SELECT COUNT(DISTINCT order_id) FROM sales_enriched WHERE product_id = product_1) AS confidence
FROM product_pairs
WHERE co_occurrence > 1
ORDER BY co_occurrence DESC, support DESC
LIMIT 20;

-- 5. Advanced Customer Segmentation
CREATE TABLE customer_segmentation AS
WITH customer_metrics AS (
  SELECT
    customer_id,
    MAX(order_date) AS last_purchase_date,
    MIN(order_date) AS first_purchase_date,
    COUNT(DISTINCT order_id) AS num_orders,
    SUM(total_amount) AS total_spent,
    AVG(total_amount) AS avg_order_value,
    SUM(CASE WHEN price > 100 THEN 1 ELSE 0 END) AS premium_purchases,
    COUNT(DISTINCT product_id) AS unique_products_purchased,
    COUNT(DISTINCT category) AS unique_categories_purchased,
    MAX(account_type) AS account_type
  FROM sales_enriched
  GROUP BY customer_id
)
SELECT
  customer_id,
  num_orders,
  total_spent,
  avg_order_value,
  DATEDIFF('day', first_purchase_date, last_purchase_date) + 1 AS customer_lifespan_days,
  unique_products_purchased,
  unique_categories_purchased,
  -- Calculate customer value metrics
  total_spent / NULLIF(DATEDIFF('day', first_purchase_date, last_purchase_date) + 1, 0) AS daily_value,
  premium_purchases / NULLIF(num_orders, 0) AS premium_purchase_ratio,
  -- Create segments
  CASE
    WHEN total_spent > 1000 AND num_orders > 3 THEN 'High Value'
    WHEN total_spent > 500 THEN 'Mid Value'
    ELSE 'Low Value'
  END AS value_segment,
  CASE
    WHEN unique_categories_purchased > 2 THEN 'Diverse'
    ELSE 'Focused'
  END AS shopping_pattern,
  account_type
FROM customer_metrics
ORDER BY total_spent DESC;

-- ===============================================================
-- PART 4: EXPORT ANALYTICS RESULTS
-- ===============================================================

-- Export time series analysis
EXPORT SELECT * FROM time_series_analysis
TO "${output_dir}/time_series_analysis_${date}.csv"
TYPE CSV
OPTIONS { 
  "header": true
};

-- Export RFM analysis
EXPORT SELECT * FROM rfm_analysis
TO "${output_dir}/rfm_analysis_${date}.csv"
TYPE CSV
OPTIONS { 
  "header": true
};

-- Export product affinities
EXPORT SELECT * FROM product_affinities
TO "${output_dir}/product_affinities_${date}.csv"
TYPE CSV
OPTIONS { 
  "header": true
};

-- Export customer segmentation
EXPORT SELECT * FROM customer_segmentation
TO "${output_dir}/customer_segmentation_${date}.csv"
TYPE CSV
OPTIONS { 
  "header": true
};

-- Export cohort analysis
EXPORT SELECT * FROM cohort_analysis
TO "${output_dir}/cohort_analysis_${date}.csv"
TYPE CSV
OPTIONS { 
  "header": true
}; 